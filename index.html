<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1.0, minimum-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover"
    />
    <meta http-equiv="X-UA-Compatible" content="ie=edge" />
    <title>Domino</title>
	<script src="/js/domino.js"></script>
    <script src="/lib/enable3d/enable3d.framework.0.25.0.min.js"></script>
	
  </head>

  <body>
    <script>
		const { Project, Scene3D, THREE, FLAT,PhysicsLoader } = ENABLE3D

		class MainScene extends Scene3D {
			async preload() {
			await this.load.preload('bridge', '/assets/svg/bridge6.svg')
			await this.load.preload('button', '/assets/button/button_sprite_sheet.png')
			await this.load.preload('face', '/assets/img/flat0.png')
			await this.load.preload('side', '/assets/img/flat0.png')
			await this.load.preload('wood', '/assets/img/wood3.jpg')
			//await this.load.preload('wood_normal', '/assets/img/wood3_normal.jpg')
			//await this.load.preload('wood_roughness', '/assets/img/wood3_roughness.jpg')
			
        }
		 	
        AddGround(){
		 const gridData = 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAEAAAABACAYAAACqaXHeAAAABHNCSVQICAgIfAhkiAAAAAlwSFlzAAAOnAAADusBZ+q87AAAAJtJREFUeJzt0EENwDAAxLDbNP6UOxh+NEYQ5dl2drFv286598GrA7QG6ACtATpAa4AO0BqgA7QG6ACtATpAa4AO0BqgA7QG6ACtATpAa4AO0BqgA7QG6ACtATpAa4AO0BqgA7QG6ACtATpAa4AO0BqgA7QG6ACtATpAa4AO0BqgA7QG6ACtATpAa4AO0BqgA7QG6ACtATpAu37AD8eaBH5JQdVbAAAAAElFTkSuQmCC';
		  /*
		    this.load.texture(gridData).then(texture => {
            //console.log(texture)
            texture.wrapS = texture.wrapT = 1000 // RepeatWrapping
            texture.repeat.set(60, 40)

            // ground
            const ground = this.physics.add.ground(
              {
                name: 'ground',
                width: 60,
                height: 40,
                depth: 1,
                y: -0.5
              },
              {
                phong: {
                  map: texture,
                  transparent: true,
                  opacity: 0.8,
                  color: 0xffffff
                }
              }
            )
            ground.body.setRestitution(1)
          })
*/		  
		  
            //console.log(texture)
            this.textureWood.wrapS = this.textureWood.wrapT = 1000 // RepeatWrapping
            this.textureWood.repeat.set(5, 5)
/*
			this.textureWoodNormal.wrapS = this.textureWoodNormal.wrapT = 5 // RepeatWrapping
			this.textureWoodNormal.repeat.set(5, 5)
			
			this.textureWoodRoughness.wrapS = this.textureWoodRoughness.wrapT = 5 // RepeatWrapping
			this.textureWoodRoughness.repeat.set(5, 5)
*/
			/*
			  const material = new THREE.MeshLambertMaterial({ map: this.textureWood,  transparent: true,
                  opacity: 1,
                  color: 0xffffff })
  */
  /*
			const material = new THREE.MeshStandardMaterial({ map: this.textureWood,  transparent: false,
					normalMap: this.textureWoodNormal,
					roughnessMap: this.textureWoodRoughness,
                  opacity: 1,
                  color: 0xffffff })
	*/
            // ground
            const ground = this.physics.add.ground(
              {
                name: 'ground',
                width: 60,
                height: 40,
                depth: 1,
                y: -0.5
              },
              {
			  
			  standard:{
			      map: this.textureWood,
				  //normalMap: this.textureWoodNormal,
				  //roughnessMap: this.textureWoodRoughness,
				  
                  transparent: true,
                  opacity: 1,
                  color: 0xffffff
				  
				  }
			  }
			  
			  /*
                phong: {
                  map: this.textureWood,
                  transparent: true,
                  opacity: 1,
                  color: 0xffffff
                }
				*/
              
            )
            ground.body.setRestitution(1)
			//ground.material=material;
			//console.log(ground)
          
		  	 /*
			 
			
                const texture2 = this.load.texture(gridData);
				const texture3 = this.load.texture(gridData);
                texture2.wrapS = texture2.wrapT = THREE.RepeatWrapping;
                texture2.repeat(21, 21);
			
                // ground
                const geometry2 = { name: 'ground', width: 41, height: 21, depth: 1, y: -0.5 };
                const material2 = {
                    //phong: { map: addGrid ? texture : null, color: 0xffffff }
					phong: { map:  texture, color: 0xffffff }
                };
                let ground;
                if (window.__loadPhysics) {
                    ground = this.physics.add.ground(geometry2, material2);
                    ground.body.setRestitution(1);
                }
                else {
                    ground = this.factories.add.ground(geometry2, material2);
                }
                ground.receiveShadow = true;
                //Features = Object.assign({ ground }, Features);
		  */
		}
		
		AddBalancator(_x,_y,_z){
			_y=_y+2.5
			const box1 = this.add.box({ x: _x+1, y: _y+0,z:_z+1.1,height: 5,width: 0.4, depth: 0.4  }, { lambert: { color: 'GoldenRod' } })
			box1.rotation.set(0, -Math.PI/2, Math.PI/8)
			this.physics.add.existing(box1)
			  // set some body properties
			box1.body.setAngularFactor(0, 0, 0)
			box1.body.setLinearFactor(0, 0, 0)
		
			const box2 = this.add.box({ x: _x+1, y: _y+0,z:_z-1.1,height: 5,width: 0.4, depth: 0.4  }, { lambert: { color: 'GoldenRod' } })
			box2.rotation.set(0, Math.PI/2, Math.PI/8)
			this.physics.add.existing(box2)
			//this.physics.add.constraints.lock (box1.body, box2.body)
			
			box2.body.setAngularFactor(0, 0, 0)
			box2.body.setLinearFactor(0, 0, 0)
			
			const box3 = this.add.box({ x: _x-1, y: _y+0,z:_z+1.1,height: 5,width: 0.4, depth: 0.4  }, { lambert: { color: 'GoldenRod' } })
			box3.rotation.set(0, -Math.PI/2, Math.PI/8)
			this.physics.add.existing(box3)
			box3.body.setAngularFactor(0, 0, 0)
			box3.body.setLinearFactor(0, 0, 0)
		
			const box4 = this.add.box({ x: _x-1, y: _y+0,z:_z-1.1,height: 5,width: 0.4, depth: 0.4  }, { lambert: { color: 'GoldenRod' } })
			box4.rotation.set(0, Math.PI/2, Math.PI/8)
			this.physics.add.existing(box4)
			box4.body.setAngularFactor(0, 0, 0)
			box4.body.setLinearFactor(0, 0, 0)
			
			
			//this.physics.add.constraints.lock (box3.body, box4.body)
			
			const cyl = this.add.cylinder({
              x: _x,
              y: _y+2.4,
              z: _z,
              radiusTop: 0.1,
              radiusBottom: 0.1,
              height: 2.4
            })
			cyl.rotation.set( Math.PI/2,0, Math.PI/2)
			this.physics.add.existing(cyl)
			//this.physics.add.constraints.fixed (box1.body, cyl.body)
			//this.physics.add.constraints.fixed (box3.body, cyl.body)
			cyl.body.setAngularFactor(0, 0, 0)
			cyl.body.setLinearFactor(0, 0, 0)
			
			
			const box5 = this.add.box({ x: _x, y: _y+1,z:_z+0.6,height: 3,width: 0.1, depth: 0.4  }, { lambert: { color: 'LightGreen' } })
			box5.rotation.set(0, -Math.PI/2, Math.PI/8)
			this.physics.add.existing(box5)
		
			const box6 = this.add.box({ x: _x, y: _y+1,z:_z-0.6,height: 3,width: 0.1, depth: 0.4  }, { lambert: { color: 'LightGreen' } })
			box6.rotation.set(0, Math.PI/2, Math.PI/8)
			this.physics.add.existing(box6)
			this.physics.add.constraints.lock(box5.body, box6.body)
			
			this.physics.add.constraints.lock(box5.body, cyl.body)
			
			this. physics.add.constraints.hinge(box5.body, cyl.body, {
				pivotA: { x: 0, y: 1.5, z: 0 },
				axisA: { z: 1 },
				})
			
		
		}

		AddDominos(x_origin,y_origin,z_origin){
			
			
		
		  

			//depart
			const Start = new Domino(this,1 + x_origin, 1,z_origin,0,0xff69b4);
			
			var serialize = Start.toJson();
			//console.log('serialize');
			//console.log(serialize);
			//var _p1 = Domino.fromJson(this, serialize);
			
			
			
			this.listDomino.push(Start);
			//Start.box.body.applyForceX(3)
			
			this.listDomino.push(new Domino(this,3 + x_origin, 1,z_origin,0,0xff69b4))
			this.listDomino.push(new Domino(this,5 + x_origin, 1,z_origin,0,0xff69b4))
			this.listDomino.push(new Domino(this,7 + x_origin, 1,z_origin,0,0xff69b4))
			this.listDomino.push(new Domino(this,9 + x_origin, 1,z_origin,0,0xff69b4))
			this.listDomino.push(new Domino(this,10.5 + x_origin, 1,z_origin,0,0xff69b4))
			//escalier
			this.listDomino.push(new Domino(this,11.75 + x_origin, 3,z_origin,0,0xff69b4))
			this.listDomino.push(new Domino(this,13 + x_origin, 4,z_origin,0,0xff69b4))
			this.listDomino.push(new Domino(this,14.25 + x_origin, 5,z_origin,0,0xff69b4))
			this.listDomino.push(new Domino(this,15.5 + x_origin, 6,z_origin,0,0xff69b4))
			this.listDomino.push(new Domino(this,16.75 + x_origin, 7.2,z_origin,0,0xff69b4))
			this.listDomino.push(new Domino(this,18.5 + x_origin, 7.2,z_origin,0,0xff69b4))
			this.listDomino.push(new Domino(this,21.10 + x_origin, 7.5,z_origin-0.2,0,0xff69b4))

			//triangle rang 1
			this.listDomino.push(new Domino(this,30.0 + x_origin, 1,z_origin - 2.5,0,0xff69b4))
			this.listDomino.push(new Domino(this,30.0 + x_origin, 1,z_origin - 0.5,0,0xff69b4))
			this.listDomino.push(new Domino(this,30.0 + x_origin, 1,z_origin + 1.5,0,0xff69b4))
			this.listDomino.push(new Domino(this,30.0 + x_origin, 1,z_origin + 3.5,0,0xff69b4))
			//triangle rang 2
			this.listDomino.push(new Domino(this,31.75 + x_origin, 1,z_origin - 2.0,0,0xff69b4))
			this.listDomino.push(new Domino(this,31.75 + x_origin, 1,z_origin - 0.5,0,0xff69b4))
			this.listDomino.push(new Domino(this,31.75 + x_origin, 1,z_origin + 1.0,0,0xff69b4))
			this.listDomino.push(new Domino(this,31.75 + x_origin, 1,z_origin + 2.5,0,0xff69b4))
			//triangle rang 3
			this.listDomino.push(new Domino(this,33.5 + x_origin, 1,z_origin + 1.8,0,0xff69b4))
			this.listDomino.push(new Domino(this,33.5 + x_origin, 1,z_origin + 0.2,0,0xff69b4))
			this.listDomino.push(new Domino(this,33.5 + x_origin, 1,z_origin - 1.2,0,0xff69b4))
			//triangle rang 4
			this.listDomino.push(new Domino(this,34.5 + x_origin, 1,z_origin + 1.6,0,0xff69b4))
			this.listDomino.push(new Domino(this,34.5 + x_origin, 1,z_origin + 0.4,0,0xff69b4))
			this.listDomino.push(new Domino(this,34.5 + x_origin, 1,z_origin - 0.8,0,0xff69b4))
			//triangle rang 5
			this.listDomino.push(new Domino(this,36.0 + x_origin, 1,z_origin - 0.2,0,0xff69b4))
			this.listDomino.push(new Domino(this,36.0 + x_origin, 1,z_origin + 1.0,0,0xff69b4))
			//triangle rang 6
			this.listDomino.push(new Domino(this,38.0 + x_origin, 1,z_origin - 0.2,0,0xff69b4))
			this.listDomino.push(new Domino(this,38.0 + x_origin, 1,z_origin + 1.0,0,0xff69b4))
			
			//ligne devant le pont
			
			this.listDomino.push(new Domino(this,38.0 + x_origin, 1,z_origin + 10.5,Math.PI,0xff69b4))
			this.listDomino.push(new Domino(this,36.0 + x_origin, 1,z_origin + 10,Math.PI,0xff69b4))
			this.listDomino.push(new Domino(this,34.0 + x_origin, 1,z_origin + 10,Math.PI,0xff69b4))
			this.listDomino.push(new Domino(this,32.0 + x_origin, 1,z_origin + 10,Math.PI,0xff69b4))
			this.listDomino.push(new Domino(this,30.0 + x_origin, 1,z_origin + 10,Math.PI,0xff69b4))
			this.listDomino.push(new Domino(this,28.0 + x_origin, 1,z_origin + 10,Math.PI,0xff69b4))
			this.listDomino.push(new Domino(this,26.0 + x_origin, 1,z_origin + 10,Math.PI,0xff69b4))
			this.listDomino.push(new Domino(this,24.0 + x_origin, 1,z_origin + 10,Math.PI,0xff69b4))
		
			this.listDomino.push(new Domino(this,22.5 + x_origin, 1,z_origin + 10,Math.PI,0xff69b4))
			//courbe vers pont
			this.listDomino.push(new Domino(this,21.3 + x_origin, 1,z_origin + 9.4 ,Math.PI-(Math.PI / 6),0xff69b4))
			this.listDomino.push(new Domino(this,20.3 + x_origin, 1,z_origin + 8.5 ,Math.PI-(Math.PI / 3),0xff69b4))

			//sous le pont	
			const bridgeStart=new Domino(this,20.0 + x_origin, 1,z_origin + 7,Math.PI/2,0xff69b4)
			this.listDomino.push(bridgeStart)
			this.listDomino.push(new Domino(this,20.0 + x_origin, 1,z_origin + 5.5,Math.PI/2,0xff69b4))
			this.listDomino.push(new Domino(this,20.0 + x_origin, 1,z_origin + 3.5,Math.PI/2,0xff69b4))
			this.listDomino.push(new Domino(this,20.0 + x_origin, 1,z_origin + 2,Math.PI/2,0xff69b4))
			this.listDomino.push(new Domino(this,20.0 + x_origin, 1,z_origin + 0,Math.PI/2,0xff69b4))
			this.listDomino.push(new Domino(this,20.0 + x_origin, 1,z_origin -2,Math.PI/2,0xff69b4))
			this.listDomino.push(new Domino(this,20.0 + x_origin, 1,z_origin -4,Math.PI/2,0xff69b4))
			
			//courbe apres le  pont
			this.listDomino.push(new Domino(this,19.50 + x_origin, 1,z_origin -5.5,Math.PI/2+Math.PI/6.0,0xff69b4))
			this.listDomino.push(new Domino(this,18.75 + x_origin, 1,z_origin -7,Math.PI/2+Math.PI/3.0,0xff69b4))
		
			//ligne droite derriere le pont
			this.listDomino.push(new Domino(this,17.5 + x_origin, 1,z_origin -7.5,Math.PI,0xff69b4))
			this.listDomino.push(new Domino(this,16.0 + x_origin, 1,z_origin -7.5,Math.PI,0xff69b4))
			this.listDomino.push(new Domino(this,14.5 + x_origin, 1,z_origin -7.5,Math.PI,0xff69b4))
			this.listDomino.push(new Domino(this,13.0 + x_origin, 1,z_origin -7.5,Math.PI,0xff69b4))
			this.listDomino.push(new Domino(this,11.5 + x_origin, 1,z_origin -7.5,Math.PI,0xff69b4))
			this.listDomino.push(new Domino(this,10.0 + x_origin, 1,z_origin -7.5,Math.PI,0xff69b4))
			this.listDomino.push(new Domino(this,8.5 + x_origin, 1,z_origin -7.5,Math.PI,0xff69b4))
			//this.listDomino.push(new Domino(this,7.0 + x_origin, 1,z_origin -7.5,0,0xff69b4))
			
			//rotation avant balancator
			this.listDomino.push(new Domino(this,5.8 +1.5+ x_origin, 1,z_origin -7,Math.PI+Math.PI/6.0,0xff69b4))
			this.listDomino.push(new Domino(this,4.7 +1.5+ x_origin, 1,z_origin -6.2,Math.PI+Math.PI/3.0,0xff69b4))
			
			//ligne droite avant balancator
			this.listDomino.push(new Domino(this,4 +1.5+ x_origin, 1,z_origin -5,-Math.PI/2,0xff69b4))
			this.listDomino.push(new Domino(this,4 +1.5+ x_origin, 1,z_origin -4,-Math.PI/2,0xff69b4))
			this.listDomino.push(new Domino(this,4 +1.5+ x_origin, 1,z_origin -3.0,-Math.PI/2,0xff69b4))
			
			//apres la balancoire
			const StartPicture=new Domino(this,4 +1.5+ x_origin, 1,z_origin +2.0,-Math.PI/2,0xff69b4)
			this.listDomino.push(StartPicture)
			this.listDomino.push(new Domino(this,4 +1.5+ x_origin, 1,z_origin +3.5,-Math.PI/2,0xff69b4))
			this.listDomino.push(new Domino(this,4 +1.5+ x_origin, 1,z_origin +5.0,-Math.PI/2,0xff69b4))
						
			
			
			
			/*
			let heart = [
				[0,0,0,0,0,0,0],
				[0,0,1,0,1,0,0],
				[0,1,1,1,1,1,0],
				[0,1,1,1,1,1,0],
				[0,0,1,1,1,0,0],
				[0,0,0,1,0,0,0],
				[0,0,0,0,0,0,0],
				];
			*/
			let heart = [
				[0,0,0,0,0,0,0,0,0],
				[0,0,1,1,0,1,1,0,0],
				[0,1,1,1,1,1,1,1,0],
				[0,1,1,1,1,1,1,1,0],
				[0,0,1,1,1,1,1,0,0],
				[0,0,0,1,1,1,0,0,0],
				[0,0,0,0,0,0,0,0,0],
				];
			
			for (let i = 0; i < 7; i++) 
			{
				let fac=1.4*i
				for (let j = 0; j < 9; j++) 
				{
				
					//console.log("H("+i+","+j+")="+heart[i][j])
					var c=0x5f5f5f
					if(heart[i][j]==1)
						c=0xdc143c//0xff69b4
					//this.listDomino.push(new Domino(this,1.1+ (1.1*j)+x_origin, 1,fac+z_origin +7.0,-Math.PI/2,0xff69b4,c)
					this.listDomino.push(new Domino(this,1.1+ (1.1*j)+x_origin, 1,fac+z_origin +7.0,-Math.PI/2,0xdc143c,c))
				}
				/*
				this.listDomino.push(new Domino(this,1+ 0+x_origin, 1,fac+z_origin +7.0,Math.PI/2,0xff69b4))
				this.listDomino.push(new Domino(this,1+ 1.5+ x_origin, 1,fac+z_origin +7.0,Math.PI/2,0xff69b4))
				this.listDomino.push(new Domino(this,1+ 3+ x_origin, 1,fac+z_origin +7.0,Math.PI/2,0xff69b4))
				this.listDomino.push(new Domino(this,1+ 4.5+ x_origin, 1,fac+z_origin +7.0,Math.PI/2,0xff69b4))
				this.listDomino.push(new Domino(this,1+ 6+ x_origin, 1,fac+z_origin +7.0,Math.PI/2,0xff69b4))
				this.listDomino.push(new Domino(this,1+ 7.5+ x_origin, 1,fac+z_origin +7.0,Math.PI/2,0xff69b4))
				this.listDomino.push(new Domino(this,1+ 9+ x_origin, 1,fac+z_origin +7.0,Math.PI/2,0xff69b4))
				*/
			}
			/*
			for (let i = 0; i < 6; i++) 
			{
				for (let j = 0; j < i; j++) 
				{
					let offset =-j*0.75
					//if (j % 2 == 0)
					//	offset -=0.5
					
					this.listDomino.push(new Domino(this,0 +1+ x_origin+ (i*1.5)+offset, 1,z_origin - (j*1.5)+9.5,Math.PI/2,0xff69b4))
					//this.listDomino.push(new Domino(this,4 +1.5+ x_origin- (i*1.5)+13.5, 1,z_origin +4.0- (j*1.5)+10,Math.PI/2,0xff69b4))
				}
			}
			*/
			
			
			
			
			//this.startbox4.body.applyForceZ(-3)
			console.log(this.listDomino);
			
		}
		
		
		 async create() {
		 
			this.renderer.setPixelRatio(window.devicePixelRatio)
		 	
			this.textureFace = await this.load.texture('face')
			this.textureSide = await this.load.texture('side')
			this.textureWood = await this.load.texture('wood')
			//this.textureWoodNormal = await this.load.texture('wood_normal')
			//this.textureWoodRoughness = await this.load.texture('wood_roughness')
			this.bridgeSVG =await this.load.file('bridge')
				
				
			//const { orbitControls } = await this.warpSpeed()
			const { camera, ground, lights, orbitControls } = await this.warpSpeed('-ground')
		   const { hemisphereLight, ambientLight, directionalLight } = lights
		   
		   	directionalLight.shadow.camera.bottom=-25
			directionalLight.shadow.camera.top=25
			directionalLight.shadow.camera.left=-25
			directionalLight.shadow.camera.right=25
	
			
			//const helper = new THREE.CameraHelper( directionalLight.shadow.camera );
			//this.scene.add( helper );

						
			// position camera
			this.camera.position.set(0, 40, 50)
			//this.camera.lookAt(0, 8, 0)
			

          // Initialize the flat elements
          this.ui = FLAT.init(this.renderer)

          // Use this if you need events on the 2D elements.
          // If you are using orbitControls, pass it to initEvents().
          // This makes sure orbitControls is not messing with the mouse move.
          FLAT.initEvents({ canvas: this.renderer.domElement, orbitControls })

          // Call Flat.destroy() on scene restart or stop
          // or simply add FLAT to the deconstructor
          this.deconstructor.add(FLAT /* same effect as FLAT.destroy */, orbitControls)

			this.listDomino=[];
			this.listBall=[];
			this.listRotator=[];
			this.listBar=[];
			this.listBridge=[];
			
			this.listDominoBackup=[];
			this.listBallBackup=[];
			this.listRotatorBackup=[];
			this.listBarBackup=[];
			this.listBridgeBackup=[];

          // add button
          const texture = await this.load.texture('button')
          texture.name = 'button'

          const width = window.innerWidth
          const height = window.innerHeight


          const button = new FLAT.Button(texture, { width: 193, height: 71 }, 2, 1, 0)
          button.setInteractive()
          button.setPosition(width / 10, height *7/ 8)
          button.setDepth(1)
          button.setScale(1)

          button.onInputOut = () => {
            console.log('Button: onInputOut')
          }
          button.onInputDown = () => {
            console.log('Button: onInputDown')
			
			//Backup
			for (const o of this.listDomino) {
				this.listDominoBackup.push(o.toJson())
			}
			for (const o of this.listBall) {
				this.listBallBackup.push(o.toJson())
			}
			for (const o of this.listRotator) {
				this.listRotatorBackup.push(o.toJson())
			}
			for (const o of this.listBar) {
				this.listBarBackup.push(o.toJson())
			}
			for (const o of this.listBridge) {
				this.listBridgeBackup.push(o.toJson())
			}
			//console.log(this.listDominoBackup);
		
		
		
			//Launch balls
			for (const b of this.listBall) {
				b.launch()
			}
			
			
					 
		
          }
          button.onInputOver = () => {
            console.log('Button: onInputOver')
          }
          this.ui.scene.add(button)
		  
		  
		  const button2 = new FLAT.Button(texture, { width: 193, height: 71 }, 2, 1, 0)
          button2.setInteractive()
          button2.setPosition(width / 10, height *6/ 8)
          button2.setDepth(1)
          button2.setScale(1)

          button2.onInputOut = () => {
            console.log('Button: onInputOut')
          }
          button2.onInputDown = () => {
            console.log('Button: onInputDown')
			
			//
			console.log('---------------destroy');
			for (const o of this.listDomino) {
				o.destroy(this)
			}
			for (const o of this.listBall) {
				o.destroy(this)
			}
			for (const o of this.listRotator) {
				o.destroy(this)
			}
			for (const o of this.listBar) {
				o.destroy(this)
			}
			for (const o of this.listBridge) {
				o.destroy(this)
			}
			
			console.log('---------------destroy Done');
			
			while(this.listDomino.length > 0) {
				this.listDomino.pop();
			}
			
			while(this.listBall.length > 0) {
				this.listBall.pop();
			}
			
			while(this.listRotator.length > 0) {
				this.listRotator.pop();
			}
			while(this.listBar.length > 0) {
				this.listBar.pop();
			}
			while(this.listBridge.length > 0) {
				this.listBridge.pop();
			}


			//console.log(this.listDomino);
			//console.log(this.listDominoBackup);
			console.log('---------------Restore');
			for (const serialize of this.listDominoBackup) {
				this.listDomino.push(Domino.fromJson(this, serialize))
			}
			/*
			for (const serialize of this.listBallBackup) {
				this.listDomino.push(Ball.fromJson(this, serialize))
			}
			*/
			
			for (const serialize of this.listRotatorBackup) {
				this.listRotator.push(Rotator.fromJson(this, serialize))
			}
			for (const serialize of this.listBarBackup) {
				this.listBar.push(Bar.fromJson(this, serialize))
			}
			for (const serialize of this.listBridgeBackup) {
				this.listBridge.push(Bridge.fromJson(this, serialize))
			}
			
			console.log(this.listDomino);
			
          }
          button2.onInputOver = () => {
            console.log('Button: onInputOver')
          }
          this.ui.scene.add(button2)
		  
			const x_origin = -20//25
			this.AddGround()
			
			this.listBall.push(new Ball(this,x_origin-6, 0,-2));
			
			this.listBar.push(new Bar(this,4 +1.7+ x_origin, 1,4,-Math.PI/2,0xff69b4,9));
			
			//this.AddBridge(x_origin+20,0,-2);
			this.listBridge.push(new Bridge(this,x_origin+20,0,-2));

			this.AddDominos(x_origin,0,-2);

			this.listRotator.push(new Rotator(this,x_origin+40,0,+2));

			this.AddBalancator(x_origin+5.5,0,-2)
			
        }

        preRender() {
          FLAT.preRender(this.renderer)
        }

        postRender() {
          FLAT.postRender(this.renderer, this.ui)
        }
		
			update() 
			{
			/*
			  //this.box.rotation.x += 0.01
			  //this.box.rotation.y += 0.01
				 if (this.input.mousePointer.leftButtonDown()) 
				 {
					//this.starer.position.x += 1
					//this.starer.body.setVelocityX(-12)
					 //this.starer.body.needUpdate = true
					 //console.log(this.starer.body)
					 if(typeof this.starer == null)
					 {
					  console.log('click in1')
					 }
					 else
					 {
						 console.log('click in')
						 //this.starer.body.physics.constraints.physicsWorld.removeConstraints()
						 //this.third.physics.destroy(this.starer)
						this.starer.body.physics.constraints.physicsWorld.removeConstraint(this.cst)
						  this.starer.body.setCollisionFlags(6)
					  this.starer.visible = false
					  this.starer.active = false
				
						 //this.third.destroy(this.starer)
						 //this.starer=null
					 }
					 
					 //  this.starer.body.setCollisionFlags(6)
				  //this.starer.visible = false
				  //this.starer.active = false
				//	this.starer.body.visible = false
				 // this.starer.body.active = false
				  
					 
					
				}
				*/
			}
      }

      // if you do not use physics, just do not use the PhysicLoader
      PhysicsLoader(
        '/lib/ammo/kripken',
        () =>
          new Project({
            anisotropy: 1, // https://threejs.org/docs/#api/en/textures/Texture.anisotropy
            antialias: true, // false by default
			
            fixedTimeStep: 1 / 60,
            gravity: { x: 0, y: -9.81, z: 0 }, // the default gravity for all scenes
            maxSubSteps: 1,
			
            //parent: 'myCustomDiv',
            renderer: new THREE.WebGLRenderer({ antialias: true }), // add a custom renderer if you want
            scenes: [ MainScene]
          })
      )
    </script>
  </body>
</html>