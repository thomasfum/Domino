<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1.0, minimum-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover"
    />
    <meta http-equiv="X-UA-Compatible" content="ie=edge" />
    <title>My Enable3d Project</title>
	
	
	
	
	    
    <!--<script src="/js/examples.js?ver=1.1.1"></script>-->
    <script src="/lib/phaser.min.js?ver=3.52.0"></script>
    <script src="/lib/enable3d/enable3d.phaserExtension.0.25.0.min.js"></script>
	
	
  </head>

  <body>
    <style>
      * body {
        margin: 0;
        padding: 0;
        overflow: hidden;
      }
    </style>

    <script>
	//https://github.com/enable3d/enable3d/blob/master/packages/common/src/physicsBody.ts
	
	
      //const { Project, Scene3D, Canvas,PhysicsLoader, THREE } = ENABLE3D
	   const { enable3d, Scene3D, Canvas,THREE  } = ENABLE3D
	   class MainScene extends Scene3D {
        constructor() {
          super('MainScene')
		  
        }
		
        init() {
          console.log('init')
			this.accessThirdDimension()
          //this.renderer.setPixelRatio(1)
          //this.renderer.setSize(window.innerWidth, window.innerHeight)
		   
        }

        preload() 
		{
          console.log('preload')
		   // (not this.load.svg)
		   this.load.html('bridge', '/assets/svg/bridge2.svg')
        }


		AddBall(chainStartX, chainStartY, chainStartZ){
			
			const nbTorus=12
			
			//feet
			this.third.add.box({ x:chainStartX+((nbTorus-0)*0.4), y: chainStartY/2,z:chainStartZ-2, height: chainStartY,width: 0.5, depth: 0.5  }, 
			{ lambert: { color: 'GoldenRod' } })
			this.third.add.box({ x:chainStartX+((nbTorus-0)*0.4), y: chainStartY,z:chainStartZ-1.25, height: 0.5,width: 0.5, depth: 2  }, 
			{ lambert: { color: 'GoldenRod' } })
			
			
		    for (let i = 2; i <= nbTorus; i++) 
			{
				// chain
				let t2 = this.third.add.torus(
					{ x: i * 0.4 + chainStartX, y: chainStartY, z: chainStartZ,tubularSegments: 16, tube: 0.05, radius: 0.25 },
					{ standard: { emissive: 0x888888, roughness: 0.4, metalness: 1 } }
				)
				if (i % 2 == 0) t2.rotateX(Math.PI / 2)
					this.third.physics.add.existing(t2, { mass: i === nbTorus ? 0 : 1 })
				// ball
				if (i === 2) 
				{
					let ball = this.third.physics.add.sphere(
						{ mass: 2, radius: 0.4, x: + chainStartX+0.2, y: chainStartY,z: chainStartZ },
						{ standard: { emissive: 0x222222, roughness: 0.4, metalness: 1 } }
						)
					this.third.physics.add.constraints.lock(t2.body, ball.body)
					this.starer=this.third.physics.add.box({mass:300, x: + chainStartX+2, y: 2.5,z: chainStartZ, height: 5,width:1, depth: 1  }, 
					{ lambert: { color: 'GoldenRod' } })
					this.cst=this.third.physics.add.constraints.lock(this.starer.body, ball.body)
					this.starer.visible = false
					
					
				}
			}
		}

        AddGround(){
		 const gridData = 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAEAAAABACAYAAACqaXHeAAAABHNCSVQICAgIfAhkiAAAAAlwSFlzAAAOnAAADusBZ+q87AAAAJtJREFUeJzt0EENwDAAxLDbNP6UOxh+NEYQ5dl2drFv286598GrA7QG6ACtATpAa4AO0BqgA7QG6ACtATpAa4AO0BqgA7QG6ACtATpAa4AO0BqgA7QG6ACtATpAa4AO0BqgA7QG6ACtATpAa4AO0BqgA7QG6ACtATpAa4AO0BqgA7QG6ACtATpAa4AO0BqgA7QG6ACtATpAu37AD8eaBH5JQdVbAAAAAElFTkSuQmCC';
		  
		    this.third.load.texture(gridData).then(texture => {
            console.log(texture)
            texture.wrapS = texture.wrapT = 1000 // RepeatWrapping
            texture.repeat.set(60, 40)

            // ground
            const ground = this.third.physics.add.ground(
              {
                name: 'ground',
                width: 60,
                height: 40,
                depth: 1,
                y: -0.5
              },
              {
                phong: {
                  map: texture,
                  transparent: true,
                  opacity: 0.8,
                  color: 0xffffff
                }
              }
            )
            ground.body.setRestitution(1)
          }) 
		  
		  	 /*
			 
			
                const texture2 = this.third.load.texture(gridData);
				const texture3 = this.load.texture(gridData);
                texture2.wrapS = texture2.wrapT = THREE.RepeatWrapping;
                texture2.repeat(21, 21);
			
                // ground
                const geometry2 = { name: 'ground', width: 41, height: 21, depth: 1, y: -0.5 };
                const material2 = {
                    //phong: { map: addGrid ? texture : null, color: 0xffffff }
					phong: { map:  texture, color: 0xffffff }
                };
                let ground;
                if (window.__loadPhysics) {
                    ground = this.physics.add.ground(geometry2, material2);
                    ground.body.setRestitution(1);
                }
                else {
                    ground = this.factories.add.ground(geometry2, material2);
                }
                ground.receiveShadow = true;
                //Features = Object.assign({ ground }, Features);
		  */
		}
		AddBridge(x,y,z){
		  // get the shape from the sve file
          const svg = this.cache.html.get('bridge')
          const bridgeShape = this.third.transform.fromSVGtoShape(svg)

          // set scaling variable
          const scale = 20//25
		  
          // extrude the shape to a 3d object
          const bridge = this.third.add.extrude({
            shape: bridgeShape[0],
            depth: 120,
			bevelEnabled: true,
            bevelSize: 1,
            bevelThickness: 1
          })

          // scale the shape
          bridge.scale.set(1 / -scale, 1 / -scale, 1 / scale)

          // add the desired shape (in this case, concave, which is always static)
          bridge.shape = 'concave'
			bridge.material = new THREE.MeshLambertMaterial({ color: 0xff0000, side: THREE.DoubleSide  })


          // offset the position by the half of the shape's size
          bridge.position.setY(bridge.geometry.boundingBox.max.y / scale+ y)
		  bridge.position.setX(x)
		  bridge.position.setZ(z)

          // add a physics body
          this.third.physics.add.existing(bridge)

          // set some body properties
          bridge.body.setAngularFactor(0, 0, 0)
          bridge.body.setLinearFactor(0, 0, 0)
		  
		  bridge.body.setFriction(0.2)
		}
		
		AddDomino(_x,_y,_z, _angle,_color)
		{
			const box1 = this.third.add.box({ x: _x, y: _y,z:_z,height: 3,width: 0.4, depth: 1  }, { lambert: { color: _color } })
			box1.rotation.set(0, _angle, 0)
			this.third.physics.add.existing(box1)
			return box1
		}
		AddDominos(x_origin,y_origin,z_origin){
			
			
			this.startbox1=this.AddDomino(1 + x_origin, 1,z_origin,0,'hotpink')
			//this.startbox1.body.applyForceX(3)
			//depart
			this.AddDomino(3 + x_origin, 1,z_origin,0,'hotpink')
			this.AddDomino(5 + x_origin, 1,z_origin,0,'hotpink')
			this.AddDomino(7 + x_origin, 1,z_origin,0,'hotpink')
			this.AddDomino(9 + x_origin, 1,z_origin,0,'hotpink')
			this.AddDomino(10.5 + x_origin, 1,z_origin,0,'hotpink')
			//escalier
			this.AddDomino(11.75 + x_origin, 3,z_origin,0,'hotpink')
			this.AddDomino(13 + x_origin, 4,z_origin,0,'hotpink')
			this.AddDomino(14.25 + x_origin, 5,z_origin,0,'hotpink')
			this.AddDomino(15.5 + x_origin, 6,z_origin,0,'hotpink')
			this.AddDomino(16.75 + x_origin, 7.2,z_origin,0,'hotpink')
			this.AddDomino(18.5 + x_origin, 7.2,z_origin,0,'hotpink')
			this.AddDomino(21.10 + x_origin, 7.5,z_origin,0,'hotpink')

			//triangle rang 1
			this.AddDomino(30.0 + x_origin, 1,z_origin - 2.5,0,'hotpink')
			this.AddDomino(30.0 + x_origin, 1,z_origin - 0.5,0,'hotpink')
			this.AddDomino(30.0 + x_origin, 1,z_origin + 1.5,0,'hotpink')
			this.AddDomino(30.0 + x_origin, 1,z_origin + 3.5,0,'hotpink')
			//triangle rang 2
			this.AddDomino(31.75 + x_origin, 1,z_origin - 2.0,0,'hotpink')
			this.AddDomino(31.75 + x_origin, 1,z_origin - 0.5,0,'hotpink')
			this.AddDomino(31.75 + x_origin, 1,z_origin + 1.0,0,'hotpink')
			this.AddDomino(31.75 + x_origin, 1,z_origin + 2.5,0,'hotpink')
			//triangle rang 3
			this.AddDomino(33.5 + x_origin, 1,z_origin + 1.8,0,'hotpink')
			this.AddDomino(33.5 + x_origin, 1,z_origin + 0.2,0,'hotpink')
			this.AddDomino(33.5 + x_origin, 1,z_origin - 1.2,0,'hotpink')
			//triangle rang 4
			this.AddDomino(34.5 + x_origin, 1,z_origin + 1.6,0,'hotpink')
			this.AddDomino(34.5 + x_origin, 1,z_origin + 0.4,0,'hotpink')
			this.AddDomino(34.5 + x_origin, 1,z_origin - 0.8,0,'hotpink')
			//triangle rang 5
			this.AddDomino(36.0 + x_origin, 1,z_origin - 0.2,0,'hotpink')
			this.AddDomino(36.0 + x_origin, 1,z_origin + 1.0,0,'hotpink')
			//triangle rang 6
			this.AddDomino(38.0 + x_origin, 1,z_origin + 0.4,0,'hotpink')
			
			//ligne devant le pont
			
			this.AddDomino(38.0 + x_origin, 1,z_origin + 10.5,0,'hotpink')
			this.AddDomino(36.0 + x_origin, 1,z_origin + 10,0,'hotpink')
			this.AddDomino(34.0 + x_origin, 1,z_origin + 10,0,'hotpink')
			this.AddDomino(32.0 + x_origin, 1,z_origin + 10,0,'hotpink')
			this.AddDomino(30.0 + x_origin, 1,z_origin + 10,0,'hotpink')
			this.AddDomino(28.0 + x_origin, 1,z_origin + 10,0,'hotpink')
			this.AddDomino(26.0 + x_origin, 1,z_origin + 10,0,'hotpink')
			this.AddDomino(24.0 + x_origin, 1,z_origin + 10,0,'hotpink')
		
			//courbe vers pont
			this.AddDomino(22.0 + x_origin, 1,z_origin + 9.5 ,-Math.PI / 6,'hotpink')
			this.AddDomino(20.5 + x_origin, 1,z_origin + 8.5 ,-Math.PI / 3,'hotpink')

			//sous le pont	
			this.startbox2=this.AddDomino(20.0 + x_origin, 1,z_origin + 7,Math.PI/2,'deepskyblue')
			this.AddDomino(20.0 + x_origin, 1,z_origin + 5,Math.PI/2,'deepskyblue')
			this.AddDomino(20.0 + x_origin, 1,z_origin + 2,Math.PI/2,'deepskyblue')
			this.AddDomino(20.0 + x_origin, 1,z_origin + 0,Math.PI/2,'deepskyblue')
			this.AddDomino(20.0 + x_origin, 1,z_origin -2,Math.PI/2,'deepskyblue')
			this.AddDomino(20.0 + x_origin, 1,z_origin -4,Math.PI/2,'deepskyblue')
			
			//courbe apres le  pont
			this.AddDomino(19.50 + x_origin, 1,z_origin -5.5,Math.PI/2+Math.PI/6.0,'deepskyblue')
			this.AddDomino(18.75 + x_origin, 1,z_origin -7,Math.PI/2+Math.PI/3.0,'deepskyblue')
		
			//ligne droite derriere le pont
			this.AddDomino(17.5 + x_origin, 1,z_origin -7.5,0,'DarkOrange')
			this.AddDomino(16.0 + x_origin, 1,z_origin -7.5,0,'DarkOrange')
			this.AddDomino(14.5 + x_origin, 1,z_origin -7.5,0,'DarkOrange')
			this.AddDomino(13.0 + x_origin, 1,z_origin -7.5,0,'DarkOrange')
			this.AddDomino(11.5 + x_origin, 1,z_origin -7.5,0,'DarkOrange')
			this.AddDomino(10.0 + x_origin, 1,z_origin -7.5,0,'DarkOrange')
			this.AddDomino(8.5 + x_origin, 1,z_origin -7.5,0,'DarkOrange')
			this.AddDomino(7.0 + x_origin, 1,z_origin -7.5,0,'DarkOrange')
			this.AddDomino(5.5 + x_origin, 1,z_origin -7.5,0,'DarkOrange')
			this.AddDomino(4.0 + x_origin, 1,z_origin -7.5,0,'DarkOrange')
			
			this.startbox2.body.applyForceZ(-3)
			//this.startbox3.body.applyForceX(3)
		}
		AddRotator(x_origin,y_origin,z_origin){
			let feet = this.third.add.box({ x:x_origin, y: y_origin+0.75,z:z_origin, height:1.5,width: 0.5, depth: 0.5  }, 
				{ lambert: { color: 'GoldenRod' } })
			let arm = this.third.add.box({ x:x_origin, y: y_origin+1.75,z:z_origin, height:0.5,width: 0.5, depth: 14  }, 
				{ lambert: { color: 'GoldenRod' } })
			
			
			this.third.physics.add.existing(feet, { mass: 100 })
			this.third.physics.add.existing(arm, { mass: 2 })
			//this.third.physics.add.constraints.fixed(feet.body, arm.body)
			
			this.third. physics.add.constraints.hinge(feet.body, arm.body, {
				pivotA: { x: 0, y: 1.0, z: 0 },
				axisA: { y: 1 },
				})
		}
		create() {
			console.log('create')

			// set up scene (light, ground, grid, sky, orbitControls)
			this.third.warpSpeed('-ground')
			//this.third.warpSpeed()
			
			// position camera
			this.third.camera.position.set(0, 15, 30)
			//this.third.camera.lookAt(0, 8, 0)
		  
			this.AddGround()
						
			const x_origin = -20//25
			 
			this.AddBall(x_origin-6, 6.5,-2);
			this.AddBridge(x_origin+20,0,-2);
		  
			this.AddDominos(x_origin,0,-2);

			this.AddRotator(x_origin+40,0,+2);
		   
        
	  
		/*	  
			this.third.physics.add.sphere({ x: 0.2 + x_origin, y: 3, z: 0, radius: 0.5 })
		   
		  
          // green sphere
          const geometry = new this.third.SphereGeometry(0.8, 16, 16)
          const material = new this.third.MeshLambertMaterial({ color: 0x00ff00 })
          const cube = new this.third.Mesh(geometry, material)
          cube.position.set(0.2, 3, 0)
          this.scene.add(cube)
          // add physics to an existing object
          this.third.physics.add.existing(cube)
		  */
		  
		 
        

		 
		  
		  
		  
		
        }

        update() {
          //this.box.rotation.x += 0.01
          //this.box.rotation.y += 0.01
		     if (this.input.mousePointer.leftButtonDown()) {
			//this.starer.position.x += 1
			//this.starer.body.setVelocityX(-12)
			 //this.starer.body.needUpdate = true
			 console.log(this.starer.body)
			 if(typeof this.starer == null)
			 {
			  console.log('click in1')
			 }
			 else
			 {
			 console.log('click in')
			 //this.starer.body.physics.constraints.physicsWorld.removeConstraints()
			 //this.third.physics.destroy(this.starer)
			this.starer.body.physics.constraints.physicsWorld.removeConstraint(this.cst)
			  this.starer.body.setCollisionFlags(6)
          this.starer.visible = false
          this.starer.active = false
	
			 //this.third.destroy(this.starer)
			 //this.starer=null
			 }
			 /*
			   this.starer.body.setCollisionFlags(6)
          this.starer.visible = false
          this.starer.active = false
		    this.starer.body.visible = false
          this.starer.body.active = false
		  */
			 
			
			}
        }
      }

	  
	   const config = {
        type: Phaser.WEBGL,
        transparent: true,
        scale: {
          mode: Phaser.Scale.FIT,
          autoCenter: Phaser.Scale.CENTER_BOTH,
          width: window.innerWidth * Math.max(1, window.devicePixelRatio / 2),
          height: window.innerHeight * Math.max(1, window.devicePixelRatio / 2)
        },
        scene: [MainScene],
		 
        ...Canvas()
      }
	  
      // load from '/lib/ammo/kripken' or '/lib/ammo/moz'
      // PhysicsLoader('/lib/ammo/moz', () => new Project({ scenes: [MainScene], antialias: true }))
	   window.addEventListener('load', () => {
        enable3d(() => new Phaser.Game(config)).withPhysics('/lib/ammo/kripken')
      })
    </script>
  </body>
</html>
